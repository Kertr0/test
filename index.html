<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>AI Audio & Gesture Master</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        :root {
            --primary: #00ff88;
            --bg: #050505;
            --glass: rgba(20, 20, 20, 0.65);
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            margin: 0; overflow: hidden; background-color: var(--bg);
            font-family: 'Segoe UI', sans-serif; color: white; user-select: none;
        }

        #canvas-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;
            background: radial-gradient(circle at center, #1a1a1a 0%, #000000 100%);
        }

        /* --- UI PANEL --- */
        .ui-panel {
            position: absolute; top: 20px; right: 20px; width: 260px;
            padding: 20px; background: var(--glass);
            backdrop-filter: blur(12px); border-radius: 16px;
            border: 1px solid var(--border); z-index: 10;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h2 { margin: 0 0 15px 0; font-size: 14px; text-transform: uppercase; letter-spacing: 1px; border-bottom: 1px solid var(--border); padding-bottom: 10px; color: #eee; }

        button {
            background: rgba(255, 255, 255, 0.05); border: 1px solid var(--border);
            color: #ccc; padding: 10px; border-radius: 8px; cursor: pointer;
            font-size: 11px; text-transform: uppercase; width: 100%; margin-bottom: 8px;
            transition: all 0.2s;
        }
        button:hover { background: rgba(255, 255, 255, 0.15); color: #fff; }
        button.active { background: var(--primary); color: #000; font-weight: bold; box-shadow: 0 0 15px rgba(0,255,136,0.2); }

        #mic-btn { border-color: #ff4444; color: #ff4444; margin-bottom: 20px; }
        #mic-btn.mic-active { border-color: var(--primary); color: var(--primary); animation: glow 2s infinite; }
        @keyframes glow { 0% {box-shadow: 0 0 0 0 rgba(0,255,136,0.4);} 70% {box-shadow: 0 0 0 10px transparent;} 100% {box-shadow: 0 0 0 0 transparent;} }

        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }

        /* --- STATUS BAR --- */
        #status-bar {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 10; background: rgba(0,0,0,0.8); padding: 8px 20px;
            border-radius: 50px; border: 1px solid var(--border);
            display: flex; align-items: center; gap: 10px; font-size: 12px;
        }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #555; }
        .dot.active { background: var(--primary); box-shadow: 0 0 8px var(--primary); }

        /* --- PREVIEW & LOADER --- */
        #webcam-preview {
            position: absolute; bottom: 20px; left: 20px; width: 120px; height: 90px;
            background: #000; border-radius: 10px; opacity: 0.6; z-index: 10;
            transform: scaleX(-1); border: 1px solid var(--border);
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 100; font-size: 14px; background: rgba(0,0,0,0.9);
            padding: 20px 40px; border-radius: 12px; border: 1px solid var(--primary);
            text-align: center; text-transform: uppercase; letter-spacing: 2px;
        }
    </style>

    <!-- LIBS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">–ó–∞–≥—Ä—É–∑–∫–∞ AI...<br><span style="font-size:10px; opacity:0.7; text-transform:none">–†–∞–∑—Ä–µ—à–∏—Ç–µ –∫–∞–º–µ—Ä—É</span></div>
    
    <div id="canvas-container"></div>
    <video id="webcam-preview" playsinline muted></video>
    
    <div id="status-bar">
        <div class="dot" id="hand-dot"></div>
        <span id="status-text">–û–∂–∏–¥–∞–Ω–∏–µ —Ä—É–∫–∏...</span>
    </div>

    <div class="ui-panel">
        <h2>–¶–µ–Ω—Ç—Ä —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è</h2>
        
        <button id="mic-btn" onclick="toggleAudio()">üé§ –í–∫–ª—é—á–∏—Ç—å –ú—É–∑—ã–∫—É</button>

        <div class="shape-grid">
            <button onclick="setShape('sphere')" class="active">–°—Ñ–µ—Ä–∞</button>
            <button onclick="setShape('heart')">–°–µ—Ä–¥—Ü–µ</button>
            <button onclick="setShape('saturn')">–°–∞—Ç—É—Ä–Ω</button>
            <button onclick="setShape('dna')">–î–ù–ö</button>
        </div>
        
        <input type="color" id="colorPicker" value="#00ff88" style="width:100%; border:none; height:30px; background:none; cursor:pointer">
        
        <div style="margin-top:15px; font-size:10px; color:#aaa; line-height:1.6">
            ü§è <b>–©–∏–ø–æ–∫:</b> –ü—Ä–∏–±–ª–∏–∑–∏—Ç—å<br>
            üïπÔ∏è <b>–†—É–∫–∞ –≤–±–æ–∫:</b> –í—Ä–∞—â–µ–Ω–∏–µ (–î–∂–æ–π—Å—Ç–∏–∫)<br>
            üëã <b>–ù–∞–∫–ª–æ–Ω:</b> –ù–∞–∫–ª–æ–Ω —Ñ–∏–≥—É—Ä—ã
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            particleCount: 18000,
            smooth: 0.08,        // –ü–ª–∞–≤–Ω–æ—Å—Ç—å (–º–µ–Ω—å—à–µ = –ø–ª–∞–≤–Ω–µ–µ)
            rotSpeed: 0.06,      // –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤—Ä–∞—â–µ–Ω–∏—è
            zoomSensitivity: 9.0 // –ß—É–≤—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑—É–º–∞
        };

        // --- STATE MANAGEMENT ---
        const state = {
            scale: 1.0,
            rotVelX: 0, rotVelY: 0, // –°–∫–æ—Ä–æ—Å—Ç–∏ –≤—Ä–∞—â–µ–Ω–∏—è
            tilt: 0,
            beat: 0,                // –°–∏–ª–∞ –±–∞—Å–∞ (0.0 - 1.0)
            baseColor: new THREE.Color(0x00ff88)
        };

        const target = {
            scale: 1.0,
            x: 0, y: 0, // –ü–æ–∑–∏—Ü–∏—è –¥–∂–æ–π—Å—Ç–∏–∫–∞ (-1 ... 1)
            tilt: 0,
            detected: false
        };

        // --- 1. THREE.JS INIT ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 8;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 2. PARTICLES & TEXTURE ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.particleCount * 3);
        const targetPositions = new Float32Array(CONFIG.particleCount * 3);
        
        // Init random positions
        for(let i=0; i<CONFIG.particleCount*3; i++) positions[i] = (Math.random()-0.5)*20;
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // Create Glow Texture
        const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
        const ctx = cvs.getContext('2d');
        const grd = ctx.createRadialGradient(16,16,0,16,16,16);
        grd.addColorStop(0,'rgba(255,255,255,1)'); 
        grd.addColorStop(0.4,'rgba(255,255,255,0.2)'); 
        grd.addColorStop(1,'transparent');
        ctx.fillStyle = grd; ctx.fillRect(0,0,32,32);
        const texture = new THREE.Texture(cvs); texture.needsUpdate = true;

        const material = new THREE.PointsMaterial({
            size: 0.08, map: texture, transparent: true, opacity: 0.8,
            blending: THREE.AdditiveBlending, depthWrite: false, color: state.baseColor
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. SHAPE LOGIC ---
        function setShape(s) {
            for(let i=0; i<CONFIG.particleCount; i++) {
                let x,y,z, r1=Math.random(), r2=Math.random();
                if(s==='sphere'){
                    const t=2*Math.PI*r1, p=Math.acos(2*r2-1), r=3.5;
                    x=r*Math.sin(p)*Math.cos(t); y=r*Math.sin(p)*Math.sin(t); z=r*Math.cos(p);
                } else if(s==='heart'){
                    const t=r1*6.28, p=r2*3.14;
                    x=16*Math.pow(Math.sin(t),3); 
                    y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
                    z=5*Math.cos(p)*Math.sin(t);
                    x*=0.18; y*=0.18; z*=0.18;
                } else if(s==='saturn') {
                    const ang=r1*6.28, dist=i<CONFIG.particleCount*0.65 ? 2.8 : 4+r2*3;
                    if(i<CONFIG.particleCount*0.65) {
                        const ph=Math.acos(2*r2-1);
                        x=dist*Math.sin(ph)*Math.cos(ang); y=dist*Math.sin(ph)*Math.sin(ang); z=dist*Math.cos(ph);
                    } else { x=Math.cos(ang)*dist; y=(r1-0.5)*0.2; z=Math.sin(ang)*dist; }
                } else { // DNA
                     const ang = (r1 * 3 * 6.28) + (i%2 * 3.14);
                     x=Math.cos(ang)*2+(r2-0.5)*0.5; y=(r1-0.5)*10; z=Math.sin(ang)*2+(r2-0.5)*0.5;
                }
                targetPositions[i*3]=x; targetPositions[i*3+1]=y; targetPositions[i*3+2]=z;
            }
            document.querySelectorAll('.shape-grid button').forEach(b=>b.classList.remove('active'));
            if(event) event.target.classList.add('active');
        }
        setShape('sphere');

        // --- 4. AUDIO SYSTEM ---
        let audioCtx, analyser, dataArray, isAudioOn = false;

        async function toggleAudio() {
            const btn = document.getElementById('mic-btn');
            if(isAudioOn) return; // Simple toggle off not implemented to keep clean
            
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                if(audioCtx.state === 'suspended') await audioCtx.resume();
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 128;
                audioCtx.createMediaStreamSource(stream).connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                isAudioOn = true;
                btn.innerText = "üîä –ê–∫—Ç–∏–≤–Ω–æ";
                btn.classList.add('mic-active');
            } catch(e) {
                alert("–û—à–∏–±–∫–∞ –º–∏–∫—Ä–æ—Ñ–æ–Ω–∞: " + e.message);
            }
        }

        // --- 5. ANIMATION LOOP ---
        function lerp(start, end, amt) { return (1-amt)*start+amt*end; }

        function animate() {
            requestAnimationFrame(animate);

            // A. Audio Processing
            let beatPulse = 0;
            if(isAudioOn && analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; 
                for(let i=0; i<8; i++) sum += dataArray[i]; // Bass frequencies
                state.beat = lerp(state.beat, (sum/8)/255, 0.2);
                beatPulse = state.beat * 0.5; // Intensity multiplier
                
                // Beat Flash Color
                if(state.beat > 0.15) {
                    const h = state.baseColor.getHSL({});
                    particles.material.color.setHSL(h.h, h.s, Math.min(1, h.l + state.beat*0.7));
                } else {
                    particles.material.color.lerp(state.baseColor, 0.1);
                }
            }

            // B. Particle Morphing
            const pos = particles.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.particleCount*3; i++) {
                pos[i] += (targetPositions[i] - pos[i]) * 0.05;
            }
            particles.geometry.attributes.position.needsUpdate = true;

            // C. Gesture Physics (Joystick & Zoom)
            if(target.detected) {
                // 1. Scale (Inverted Pinch)
                state.scale = lerp(state.scale, target.scale, CONFIG.smooth);
                
                // 2. Rotation (Velocity based - Joystick)
                // If hand is far from center (>0.15), add to velocity
                const targetVelY = (Math.abs(target.x) > 0.15) ? target.x * CONFIG.rotSpeed : 0;
                const targetVelX = (Math.abs(target.y) > 0.15) ? target.y * CONFIG.rotSpeed : 0;
                
                state.rotVelY = lerp(state.rotVelY, targetVelY, CONFIG.smooth);
                state.rotVelX = lerp(state.rotVelX, targetVelX, CONFIG.smooth);
                
                // 3. Tilt (Direct mapping)
                state.tilt = lerp(state.tilt, -target.tilt, CONFIG.smooth);
            } else {
                // Idle State
                state.scale = lerp(state.scale, 1.0, 0.05);
                state.rotVelY = lerp(state.rotVelY, 0.002, 0.05); // Slow idle spin
                state.rotVelX = lerp(state.rotVelX, 0, 0.05);
                state.tilt = lerp(state.tilt, 0, 0.05);
                // Return color to base
                if(!isAudioOn) particles.material.color.lerp(state.baseColor, 0.1);
            }

            // D. Apply Transforms (Gestures + Audio Pulse)
            const finalScale = state.scale + beatPulse;
            particles.scale.set(finalScale, finalScale, finalScale);
            particles.rotation.y += state.rotVelY;
            particles.rotation.x += state.rotVelX;
            particles.rotation.z = state.tilt;

            renderer.render(scene, camera);
        }
        animate();

        // --- 6. HAND TRACKING ---
        const videoElement = document.getElementById('webcam-preview');
        const statusText = document.getElementById('status-text');
        const handDot = document.getElementById('hand-dot');

        function onResults(results) {
            // Hide loader once
            const loader = document.getElementById('loading');
            if(loader) loader.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                target.detected = true;
                statusText.innerText = "–†—É–∫–∞ –Ω–∞–π–¥–µ–Ω–∞";
                handDot.classList.add('active');

                const lm = results.multiHandLandmarks[0];

                // 1. PINCH (Zoom) logic
                const dist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                // Close pinch (0.02) -> Scale 2.5
                // Open hand (0.2)   -> Scale 0.5
                target.scale = Math.max(0.5, Math.min(2.8 - (dist * CONFIG.zoomSensitivity), 3.0));

                // 2. JOYSTICK (Position) logic
                // Center is 0.5. Range -1 to 1.
                // Flip X because webcam is mirrored visually
                target.x = ((lm[0].x + lm[9].x) / 2 - 0.5) * 2; 
                target.y = ((lm[0].y + lm[9].y) / 2 - 0.5) * 2;

                // 3. TILT logic
                target.tilt = Math.atan2(lm[9].y - lm[0].y, lm[9].x - lm[0].x) + Math.PI/2;

            } else {
                target.detected = false;
                statusText.innerText = "–ü–æ–∫–∞–∂–∏—Ç–µ —Ä—É–∫—É";
                handDot.classList.remove('active');
            }
        }

        // Initialize MediaPipe
        try {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240
            });
            cameraUtils.start();
        } catch(e) {
            alert("–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –∫–∞–º–µ—Ä—ã: " + e);
        }

        // Utils
        document.getElementById('colorPicker').addEventListener('input', (e) => {
            state.baseColor.set(e.target.value);
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Fail-safe timeout for loader
        setTimeout(() => { if(document.getElementById('loading')) document.getElementById('loading').style.display='none'; }, 4000);

    </script>
</body>
</html>