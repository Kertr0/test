<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>AI Particles: Fullscreen Immersion</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        :root {
            --primary: #00ff88;
            --glass: rgba(15, 15, 15, 0.9);
            --border: rgba(255, 255, 255, 0.2);
            --success: #00ff00;
            --error: #ff3333;
        }
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: 'Segoe UI', sans-serif; color: white; user-select: none;
        }

        /* --- –≠–ö–†–ê–ù –ó–ê–ü–£–°–ö–ê --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #222 0%, #000 100%);
            z-index: 999; display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
        }
        #start-btn {
            padding: 18px 50px; font-size: 16px; background: var(--primary); color: #000;
            border: none; border-radius: 50px; cursor: pointer; font-weight: 800;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4); text-transform: uppercase;
            transition: 0.2s;
        }
        #start-btn:hover { transform: scale(1.05); }

        /* --- UI PANEL --- */
        #canvas-container { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1; }
        
        .ui-panel {
            position: absolute; top: 20px; right: 20px; width: 260px;
            background: var(--glass); backdrop-filter: blur(15px);
            padding: 20px; border-radius: 16px; border: 1px solid var(--border);
            z-index: 10; display: none; transition: opacity 0.5s;
        }
        
        /* –ì–†–ò–î –î–õ–Ø –ö–ù–û–ü–û–ö */
        .toggle-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px; }
        
        button.toggle-btn {
            background: rgba(255,255,255,0.1); border: 2px solid transparent;
            color: #ccc; padding: 12px; border-radius: 8px; cursor: pointer;
            font-size: 11px; text-transform: uppercase; font-weight: bold;
            transition: all 0.3s ease;
        }
        
        button.toggle-btn.active { background: rgba(255,255,255,0.2); color: #fff; }
        button.toggle-btn.off { opacity: 0.5; text-decoration: line-through; }

        /* –ö–ù–û–ü–ö–ê FULLSCREEN */
        #btn-full {
            width: 100%; margin-bottom: 20px;
            background: rgba(0,0,0,0.5); border: 1px solid var(--primary); color: var(--primary);
        }

        /* –°–¢–ê–¢–£–°–´ –ö–ê–ú–ï–†–´ */
        #btn-cam.status-lost { border-color: var(--error); box-shadow: 0 0 5px rgba(255, 50, 50, 0.2); }
        #btn-cam.status-ok { border-color: var(--success); box-shadow: 0 0 15px rgba(0, 255, 0, 0.5); color: var(--success); }

        /* –§–û–†–ú–´ */
        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button.shape-btn {
            background: rgba(255,255,255,0.05); border: 1px solid var(--border);
            color: #ccc; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 11px;
        }
        button.shape-btn.active { background: var(--primary); color: #000; font-weight: bold; }
        
        /* –í–ò–î–ï–û –ü–†–ï–í–¨–Æ */
        #webcam-preview {
            position: absolute; bottom: 20px; left: 20px; width: 140px; height: 105px;
            background: #000; border: 1px solid var(--border); z-index: 10;
            border-radius: 10px; transform: scaleX(-1); 
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        #webcam-preview.visible { opacity: 0.7; pointer-events: auto; }

        /* --- –†–ï–ñ–ò–ú FULLSCREEN --- */
        /* –ö–æ–≥–¥–∞ body –∏–º–µ–µ—Ç –∫–ª–∞—Å—Å clean-mode, —Å–∫—Ä—ã–≤–∞–µ–º –≤—Å—ë –ª–∏—à–Ω–µ–µ */
        body.clean-mode .ui-panel,
        body.clean-mode #webcam-preview {
            opacity: 0 !important;
            pointer-events: none !important;
        }

        /* –ü–æ–¥—Å–∫–∞–∑–∫–∞ –≤—ã—Ö–æ–¥–∞ */
        #fs-hint {
            position: absolute; top: 10%; left: 50%; transform: translate(-50%, -50%);
            color: rgba(255,255,255,0.6); font-size: 14px; pointer-events: none;
            opacity: 0; transition: opacity 1s; z-index: 50;
            text-shadow: 0 0 10px black; text-transform: uppercase; letter-spacing: 2px;
        }
        body.clean-mode #fs-hint { animation: fadeHint 4s forwards; }
        @keyframes fadeHint { 0% {opacity:0;} 20% {opacity:1;} 80% {opacity:1;} 100% {opacity:0;} }

    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="start-screen">
        <h1 style="letter-spacing: 2px;">AI IMMERSION</h1>
        <button id="start-btn" onclick="startSystem()">–ó–ê–ü–£–°–¢–ò–¢–¨</button>
        <p style="color:#666; font-size:12px; margin-top:15px">–†–∞–∑—Ä–µ—à–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º</p>
    </div>

    <div id="canvas-container"></div>
    <video id="webcam-preview" class="visible" playsinline autoplay muted></video>
    
    <div id="fs-hint">–î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è –≤—ã—Ö–æ–¥–∞</div>

    <div class="ui-panel" id="ui-panel">
        <h3 style="margin:0 0 10px 0; font-size:12px; color:#888;">–£–ü–†–ê–í–õ–ï–ù–ò–ï</h3>
        
        <div class="toggle-grid">
            <button id="btn-mic" class="toggle-btn active" onclick="toggleMic()">üé§ –ó–≤—É–∫</button>
            <button id="btn-cam" class="toggle-btn active status-lost" onclick="toggleCam()">üì∑ –í–∏–¥–µ–æ</button>
        </div>
        
        <button id="btn-full" class="toggle-btn" onclick="toggleFullscreen()">üñ•Ô∏è –ü–æ–ª–Ω—ã–π —ç–∫—Ä–∞–Ω</button>

        <h3 style="margin:0 0 10px 0; font-size:12px; color:#888;">–ì–ï–û–ú–ï–¢–†–ò–Ø</h3>
        <div class="shape-grid">
            <button class="shape-btn active" onclick="setShape('sphere')">–°—Ñ–µ—Ä–∞</button>
            <button class="shape-btn" onclick="setShape('heart')">–°–µ—Ä–¥—Ü–µ</button>
            <button class="shape-btn" onclick="setShape('saturn')">–°–∞—Ç—É—Ä–Ω</button>
            <button class="shape-btn" onclick="setShape('dna')">–î–ù–ö</button>
        </div>
        
        <input type="color" id="colorPicker" value="#00ff88" style="width:100%; height:30px; border:none; background:none; cursor:pointer;">
        
        <div style="font-size:10px; color:#555; margin-top:10px; text-align:center;">
            –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –ø–æ —ç–∫—Ä–∞–Ω—É –¥–ª—è —Å–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const CONFIG = { particleCount: 18000, baseSize: 0.08, smooth: 0.08 };
        const STATE = {
            scale: 1, audioPulse: 0, rotX: 0, rotY: 0, tilt: 0,
            baseColor: new THREE.Color(0x00ff88)
        };
        const TARGET = { scale: 1, x: 0, y: 0, tilt: 0, detected: false };
        
        let scene, camera, renderer, particles;
        let audioCtx, analyser, dataArray;
        let isAudioAllowed = false;

        // --- 1. FULLSCREEN LOGIC ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable full-screen mode: ${err.message}`);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // –°–ª—É—à–∞–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ (Esc –∏–ª–∏ –∫–Ω–æ–ø–∫–∞)
        document.addEventListener('fullscreenchange', () => {
            const body = document.body;
            if (document.fullscreenElement) {
                body.classList.add('clean-mode');
            } else {
                body.classList.remove('clean-mode');
            }
        });

        // –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è –≤—Ö–æ–¥–∞/–≤—ã—Ö–æ–¥–∞
        document.addEventListener('dblclick', toggleFullscreen);

        // --- 2. START SYSTEM ---
        async function startSystem() {
            document.getElementById('start-btn').innerText = "–ó–ê–ì–†–£–ó–ö–ê...";
            
            initThree();

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isAudioAllowed = true;
            } catch(e) {
                console.warn("Mic failed");
                document.getElementById('btn-mic').classList.replace('active', 'off');
            }

            await initMediaPipe();

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-panel').style.display = 'block';
        }

        // --- 3. TOGGLES ---
        function toggleMic() {
            if(!audioCtx) return;
            const btn = document.getElementById('btn-mic');
            if(audioCtx.state === 'running') {
                audioCtx.suspend();
                btn.classList.replace('active', 'off');
                STATE.audioPulse = 0;
            } else {
                audioCtx.resume();
                btn.classList.replace('off', 'active');
            }
        }

        function toggleCam() {
            const vid = document.getElementById('webcam-preview');
            const btn = document.getElementById('btn-cam');
            if(vid.classList.contains('visible')) {
                vid.classList.remove('visible');
            } else {
                vid.classList.add('visible');
            }
        }

        // --- 4. THREE.JS ---
        let targetPositions = new Float32Array(CONFIG.particleCount * 3);

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 8;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0,'white'); grad.addColorStop(1,'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(cvs); tex.needsUpdate = true;

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.particleCount * 3);
            for(let i=0; i<CONFIG.particleCount*3; i++) pos[i] = (Math.random()-0.5)*20;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            const mat = new THREE.PointsMaterial({
                size: CONFIG.baseSize, map: tex, transparent: true, opacity: 0.8,
                blending: THREE.AdditiveBlending, depthWrite: false, color: STATE.baseColor
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);
            setShape('sphere');
            animate();
        }

        function lerp(s, e, a) { return (1-a)*s + a*e; }

        function animate() {
            requestAnimationFrame(animate);

            if (isAudioAllowed && audioCtx.state === 'running' && analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for(let i=0; i<8; i++) sum+=dataArray[i];
                STATE.audioPulse = lerp(STATE.audioPulse, (sum/8)/255, 0.2);
                
                if(STATE.audioPulse > 0.35) {
                    const h = STATE.baseColor.getHSL({});
                    particles.material.color.setHSL(h.h, h.s, Math.min(1, 0.5 + STATE.audioPulse));
                } else {
                    particles.material.color.lerp(STATE.baseColor, 0.1);
                }
            }

            if (TARGET.detected) {
                STATE.scale = lerp(STATE.scale, TARGET.scale, CONFIG.smooth);
                const vx = (Math.abs(TARGET.x)>0.1) ? TARGET.x*0.05 : 0;
                const vy = (Math.abs(TARGET.y)>0.1) ? TARGET.y*0.05 : 0;
                STATE.rotY = lerp(STATE.rotY, vx, CONFIG.smooth);
                STATE.rotX = lerp(STATE.rotX, vy, CONFIG.smooth);
                STATE.tilt = lerp(STATE.tilt, -TARGET.tilt, CONFIG.smooth);
            } else {
                STATE.scale = lerp(STATE.scale, 1, 0.05);
                STATE.rotY = lerp(STATE.rotY, 0.002, 0.05);
                STATE.rotX = lerp(STATE.rotX, 0, 0.05);
                STATE.tilt = lerp(STATE.tilt, 0, 0.05);
            }

            const totalScale = STATE.scale + (STATE.audioPulse * 0.5);
            particles.scale.set(totalScale, totalScale, totalScale);
            particles.rotation.y += STATE.rotY;
            particles.rotation.x += STATE.rotX;
            particles.rotation.z = STATE.tilt;

            const p = particles.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.particleCount*3; i++) p[i] += (targetPositions[i]-p[i])*0.08;
            particles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // --- 5. MEDIAPIPE ---
        async function initMediaPipe() {
            const vid = document.getElementById('webcam-preview');
            vid.width = 320; vid.height = 240;

            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            const camBtn = document.getElementById('btn-cam');

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    TARGET.detected = true;
                    // –ó–ï–õ–ï–ù–´–ô –°–¢–ê–¢–£–°
                    camBtn.classList.remove('status-lost');
                    camBtn.classList.add('status-ok');

                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    TARGET.scale = Math.max(0.5, Math.min(3.0 - (dist*10), 3.0));
                    TARGET.x = ((lm[9].x)-0.5)*2;
                    TARGET.y = ((lm[9].y)-0.5)*2;
                    TARGET.tilt = Math.atan2(lm[9].y-lm[0].y, lm[9].x-lm[0].x) + Math.PI/2;
                } else {
                    TARGET.detected = false;
                    // –ö–†–ê–°–ù–´–ô –°–¢–ê–¢–£–°
                    camBtn.classList.remove('status-ok');
                    camBtn.classList.add('status-lost');
                }
            });

            const camera = new Camera(vid, {
                onFrame: async () => { await hands.send({image: vid}); },
                width: 320, height: 240
            });
            return camera.start();
        }

        // --- UTILS ---
        window.setShape = function(s) {
            for(let i=0; i<CONFIG.particleCount; i++) {
                let x,y,z, r1=Math.random(), r2=Math.random();
                if(s==='sphere'){const t=r1*6.28, p=Math.acos(2*r2-1), r=3.5;x=r*Math.sin(p)*Math.cos(t); y=r*Math.sin(p)*Math.sin(t); z=r*Math.cos(p);} 
                else if(s==='heart'){const t=r1*6.28, p=r2*3.14;x=16*Math.pow(Math.sin(t),3); y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);z=5*Math.cos(p)*Math.sin(t); x*=0.18; y*=0.18; z*=0.18;} 
                else if(s==='saturn') {const ang=r1*6.28, dist=i<CONFIG.particleCount*0.7?2.8:4+r2*3;if(i<CONFIG.particleCount*0.7){const ph=Math.acos(2*r2-1); x=dist*Math.sin(ph)*Math.cos(ang);y=dist*Math.sin(ph)*Math.sin(ang);z=dist*Math.cos(ph);}else{x=Math.cos(ang)*dist;y=(r1-0.5)*0.3;z=Math.sin(ang)*dist;}} 
                else {const ang=(r1*3*6.28)+(i%2*3.14); x=Math.cos(ang)*2+(r2-0.5); y=(r1-0.5)*10; z=Math.sin(ang)*2+(r2-0.5);}
                targetPositions[i*3]=x; targetPositions[i*3+1]=y; targetPositions[i*3+2]=z;
            }
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            if(event) event.target.classList.add('active');
        };
        document.getElementById('colorPicker').addEventListener('input', (e) => STATE.baseColor.set(e.target.value));
        window.addEventListener('resize', () => {camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);});
    </script>
</body>
</html>